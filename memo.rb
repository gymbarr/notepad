class Memo < Post
  # Напишем реализацию метода read_from_console для экземпляра заметки. Он
  # спрашивает у пользователя текст заметки все строки (до слова end) и
  # записывает их в переменную экземпляра, массив @text.
  def read_from_console
    puts 'Новая заметка (все, что пишите до строчки "end"):'

    # Для старта цикла запишем в переменную line nil
    line = nil

    # Пока в переменной line не окажется (пока пользователь не введет) слово
    # «end», крутимся в цикле и считываем строку за строкой в массив @text.
    until line == 'end'
      # Читаем очередную строку и записываем из ввода пользователя
      line = STDIN.gets.chomp

      # Напомню, что изначально в переменной @text у нас пустой массив (смотрите
      # конструктор класса-родителя Post).
      @text << line
    end

    # Удаляем пустые строки из массива строк
    @text.reject! { |line| line.empty? }

    # Удалим последний элемент из массива @text — там служебное слово «end»,
    # которое мы не хотим видеть в нашей заметке.
    @text.pop
  end

  # Этот метод возвращает состояние объекта в виде массива строк
  def to_strings
    time_string = "Создано: #{@created_at.strftime("%Y.%m.%d, %H:%M:%S")} \n \n"

     @text.unshift(time_string)
  end

  # Метод возвращает ассоциативный массив с параметрами Задачи, который будем использовать для вставки в БД
  def to_db_hash
    # вызываем родительский метод ключевым словом super и к хэшу, который он вернул
    # присоединяем прицепом специфичные для этого класса поля методом Hash#merge
    super.merge(
      {
        'text' => @text.join("\n") # Массив строк собираем в одну строку с добавлением символа переноса строки
      }
    )
  end

  #  получает на вход хэш массив данных и должен заполнить свои поля
  def load_data(data_hash)
    super(data_hash) # дергаем родительский метод для инициализации общих полей

  #  теперь прописываем свое специфичное поле
     @text = data_hash['text'].split('\n')
  end
end
